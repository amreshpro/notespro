### 1.1 What is Spring Boot?
Spring Boot is a framework that simplifies the development of Spring-based applications. It removes boilerplate code and provides built-in functionalities like:
- ‚úÖ Auto-configuration (No need for manual XML configuration)
- ‚úÖ Embedded servers (Tomcat, Jetty, Undertow)
- ‚úÖ Production-ready features (Monitoring, Logging, Security)
- ‚úÖ Microservices support

### 1.2 Features of Spring Boot
- üîπ Standalone ‚Äì No need for an external web server (Tomcat is built-in).
- üîπ Opinionated Defaults ‚Äì Provides pre-configured settings for faster development.
- üîπ Spring Boot Starters ‚Äì Predefined dependencies for common use cases.
- üîπ Spring Boot CLI ‚Äì Command-line tool to run Spring applications.
- üîπ Spring Boot Actuator ‚Äì Monitoring & management tools.

### 1.3 Difference Between Spring and Spring Boot

| Feature | Spring | Spring Boot |
| :-----: | :----: | :----------: |
| Configuration | Manual XML or Java Config | Auto-configuration |
| Server | Requires external Tomcat/Jetty | Embedded Tomcat, Jetty |
| Dependencies | Manually added | Uses Spring Boot Starters |
| Setup Time | Takes time to configure | Quick setup with Spring Initializr |
| Microservices | Needs additional setup | Built-in support |

```pgsql
my-spring-boot-app
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ main
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/example/demo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DemoApplication.java  <-- Main class
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controller
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resources
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.properties  <-- Configuration file
‚îÇ   ‚îú‚îÄ‚îÄ test  <-- Unit tests
‚îú‚îÄ‚îÄ pom.xml  <-- Maven dependencies

```


#### This is the entry point of your Spring Boot app.

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication  // Enables auto-configuration and component scanning
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

```


#### REST Controller

```java
package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController  // Marks this class as a REST API controller
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")  // Handles HTTP GET requests at /api/hello
    public String sayHello() {
        return "Hello, Spring Boot!";
    }
}

```



#### Run the Application
```bash
mvn spring-boot:run
```
Open browser and visit:
http://localhost:8080/api/hello
‚úÖ You should see: "Hello, Spring Boot!" üéâ



###  application.properties (Configuration File)
Spring Boot uses application.properties to configure settings.

```properties
# Application Settings
server.port=9090  # Default port is 8080
```
Now your app will run on http://localhost:9090 instead of 8080.


## Chapter 2

Spring Boot automatically configures beans and components based on the dependencies present in the classpath.

####  Without Auto-Configuration (Traditional Spring)

Before Spring Boot, you had to manually configure the beans in XML or Java:

```xml
<bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="password"/>
</bean>

```


#### With Auto-Configuration (Spring Boot)
Spring Boot removes this manual work:

```properties
# Database Configuration
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
```

‚úÖ No XML, No Extra Java Code! Spring Boot auto-configures the DataSource when it detects MySQL driver in pom.xml.


### How Does Auto-Configuration Work?

- 1Ô∏è‚É£ Spring Boot scans the classpath for dependencies.
- 2Ô∏è‚É£ If a required JAR file is present, Spring Boot automatically configures the related beans.
- 3Ô∏è‚É£ The @EnableAutoConfiguration annotation loads default configurations from spring-boot-autoconfigure package.

### Understanding @SpringBootApplication

When you create a Spring Boot project, you see this annotation on the main class:

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

```

This annotation is equivalent to 3 separate annotations:

```java
@Configuration  // Marks this class for Spring configuration
@EnableAutoConfiguration  // Enables auto-configuration
@ComponentScan  // Scans components in the package

```

‚úÖ Reduces boilerplate code and simplifies setup!


### Spring Boot Starter Dependencies

Spring Boot provides predefined dependencies for common use cases called Starters.

Adding Spring Boot Starters in pom.xml

```xml 
<!-- Spring Boot Web Starter (For REST APIs) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

```

|Starter|Purpose|
|:-----:|:-----:|
|spring-boot-starter-web | Build REST APIs (Spring MVC, Embedded Tomcat)|
| spring-boot-starter-data-jpa |Database access with JPA & Hibernate|
|spring-boot-starter-security|Security & Authentication|
|spring-boot-starter-thymeleaf |Spring MVC + Thymeleaf Templating |
|spring-boot-starter-test|Unit Testing with JUnit & Mockito|


‚úÖ Less dependency management, faster development!



## Customizing Auto-Configuration
Sometimes, you might want to override the default auto-configuration.

### Customizing DataSource Bean
Instead of using application.properties, you can manually define a DataSource Bean:

```java 

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.sql.DataSource;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource customDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
}

```

‚úÖ Overrides the default DataSource configuration!


### Disabling Auto-Configuration
If you don‚Äôt want Spring Boot to auto-configure certain components, you can exclude them:

####  Excluding DataSource Auto-Configuration
```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

```

‚úÖ Useful when you don‚Äôt need a database but Spring Boot tries to configure it!

‚úÖ Summary
‚úî Auto-Configuration automatically configures Spring beans based on dependencies.
‚úî @SpringBootApplication is a combination of @Configuration, @EnableAutoConfiguration, and @ComponentScan.
‚úî Spring Boot Starters simplify dependency management.
‚úî You can customize or disable auto-configuration when needed.


 ## Spring Boot Dependency Injection (DI) & IoC üîÑ

- ‚úÖ What is Dependency Injection (DI)?
- ‚úÖ How does IoC (Inversion of Control) work?
- ‚úÖ Types of Dependency Injection (Constructor, Setter, Field Injection)
- ‚úÖ Using @Autowired Annotation
- ‚úÖ Bean Scope & Lifecycle
- ‚úÖ Creating Custom Beans using @Bean


 ### What is Dependency Injection? ü§î
Dependency Injection (DI) is a design pattern where dependencies (objects) are injected into a class instead of being created manually inside the class.

‚úÖ This makes the code loosely coupled, more testable, and maintainable.


- Without Dependency Injection (Tightly Coupled)
```java
class Car {
    private Engine engine;

    public Car() {
        this.engine = new Engine();  // Manual object creation
    }
}
  
```

üö® Problem:

Hardcoded dependencies ‚Üí Difficult to change/test Engine.
Tightly Coupled ‚Üí If we want a different engine, we must modify Car class.

-  With Dependency Injection (Loosely Coupled)
  
  ```java
class Car {
    private Engine engine;

    // Dependency Injection via Constructor
    public Car(Engine engine) {
        this.engine = engine;
    }
}

  ```

  ‚úÖ Now Car doesn‚Äôt depend on how Engine is created!

## IoC (Inversion of Control) in Spring
In traditional Java, we manually create objects using new().
In Spring, the IoC (Inversion of Control) Container manages objects (Beans) for us.

How IoC Works in Spring?
- 1Ô∏è‚É£ We define a Bean (a Java object managed by Spring).
- 2Ô∏è‚É£ Spring Container creates and injects dependencies automatically.
- 3Ô∏è‚É£ We don‚Äôt need new() manually.



### IoC in Spring Boot

```java
@Component
class Engine {
    public void start() {
        System.out.println("Engine started...");
    }
}

@Component
class Car {
    private Engine engine;

    @Autowired  // Injecting Engine automatically
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving...");
    }
}

```

### 1.Constructor Injection (Best Practice)

 Most recommended ‚Üí Ensures mandatory dependencies at object creation.

 ```java
@Component
class Engine {
    public void start() {
        System.out.println("Engine started...");
    }
}

@Component
class Car {
    private final Engine engine;

    @Autowired
    public Car(Engine engine) {  // Injecting Engine via Constructor
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving...");
    }
}

 ```

 ‚úÖ Advantages of Constructor Injection
- ‚úî Ensures mandatory dependencies at object creation.
- ‚úî Works well with immutable objects (final fields).
- ‚úî Better for Unit Testing.

 ### 2.Setter Injection
üîπ Used when dependency is optional.
```java
@Component
class Car {
    private Engine engine;

    @Autowired
    public void setEngine(Engine engine) {  // Injecting Engine via Setter
        this.engine = engine;
    }
}

```
- ‚úÖ Good when dependencies need to change after object creation.
- üö® But: Allows object creation without the dependency (not always ideal).


 ## 3.Field Injection (Avoid ‚ö†)
 üîπ Uses @Autowired directly on a field.
 ```java
@Component
class Car {
    @Autowired
    private Engine engine;
}

 ```

 üö® Why Avoid Field Injection?

- Harder to test (can‚Äôt mock dependencies easily).
- Breaks immutability.
- Not recommended for large projects.

‚úÖ Use Constructor Injection instead!

### Creating Custom Beans using @Bean
Sometimes, we need to manually create beans in Spring Boot.
We use @Configuration + @Bean for this.

```java 

@Configuration
public class AppConfig {

    @Bean
    public Engine customEngine() {  // Custom Bean
        return new Engine();
    }
}

```


## Bean Scope in Spring Boot
Spring Boot provides different scopes for beans:

|Scope |Description|
|:------|:---------|
|Singleton(Default)|Only one instance of the bean exist|
|Prototype|A new instance is created every time|
|Request|New instance for each HTTP request(Web Apps)|
|Session|New instance for each HTTP session(Web Apps)|

### Setting Bean Scope
```java
@Component
@Scope("prototype")  // New instance every time
class Engine { }

```

‚úÖ Summary
- ‚úî Dependency Injection (DI) makes code loosely coupled & testable.
- ‚úî IoC (Inversion of Control) lets Spring manage dependencies instead of new().
- ‚úî Constructor Injection is the best practice.
- ‚úî Setter Injection is useful for optional dependencies.
- ‚úî Field Injection should be avoided.
- ‚úî Spring Boot Beans can be customized using @Bean & @Configuration.
- ‚úî Bean Scope controls how beans are created & reused.

## Spring Boot REST API Development üåê
- ‚úÖ What is a REST API?
- ‚úÖ Creating a Spring Boot REST API using @RestController
- ‚úÖ Handling HTTP Methods (GET, POST, PUT, DELETE)
- ‚úÖ Path Variables & Query Parameters
- ‚úÖ Response Status Codes (@ResponseStatus)
- ‚úÖ Exception Handling (@ControllerAdvice)

### What is a REST API? ü§î
A REST API (Representational State Transfer API) is a way to communicate between client and server over HTTP.

Follows CRUD operations:
- Create ‚Üí POST
- Read ‚Üí GET
- Update ‚Üí PUT
- Delete ‚Üí DELETE
  
üìå Spring Boot makes REST API development easy with @RestController.

#### Create a REST Controller
- üîπ Use @RestController to handle HTTP requests.
- üîπ Use @RequestMapping("/path") to define API routes.
  

```java

@RestController
@RequestMapping("/users")  // Base path for APIs
public class UserController {
    @GetMapping("/hello")  // GET request
    public String sayHello() {
        return "Hello from Spring Boot REST API!";
    }
}

```

‚úÖ Start the application and visit:


```bash
http://localhost:8080/users/hello
```
üìå You will see "Hello from Spring Boot REST API!"



## GET Request - Fetch Data
üîπ @GetMapping is used for retrieving data.

```java

@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")  // GET request with Path Variable
    public String getUserById(@PathVariable int id) {
        return "User ID: " + id;
    }
}

```
‚úÖ Test in Browser/Postman:

```bash
GET http://localhost:8080/users/5
```
üìå Output: "User ID: 5"

#### POST Request - Create Data
üîπ @PostMapping is used for creating data.
üîπ Use @RequestBody to get data from the request body.

```java
@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping
    public String createUser(@RequestBody User user) {
        return "User " + user.getName() + " created!";
    }
}
```

‚úÖ Send JSON Data in Postman:


```bash
POST http://localhost:8080/users
Body: { "name": "Amresh", "email": "amresh@example.com" }
```
üìå Output: "User Amresh created!"

#### PUT Request - Update Data
üîπ @PutMapping is used for updating data.

```java
@PutMapping("/{id}")
public String updateUser(@PathVariable int id, @RequestBody User user) {
    return "User ID " + id + " updated with name " + user.getName();
}
```
‚úÖ Test in Postman:

```bash
PUT http://localhost:8080/users/5
Body: { "name": "Updated Name" }
```
üìå Output: "User ID 5 updated with name Updated Name"

#### DELETE Request - Remove Data

üîπ @DeleteMapping is used for deleting data.

```java
@DeleteMapping("/{id}")
public String deleteUser(@PathVariable int id) {
    return "User ID " + id + " deleted!";
}
```

‚úÖ Test in Postman:


```bash
DELETE http://localhost:8080/users/5
```
üìå Output: "User ID 5 deleted!"

#### Path Variables vs Query Parameters
Path Variable (/{id}) ‚Üí Used for identification.
Query Parameter (?key=value) ‚Üí Used for filtering/searching.
üîπ Path Variable Example:

```java
@GetMapping("/{id}")
public String getUserById(@PathVariable int id) {
    return "User ID: " + id;
}

```

üîπ Query Parameter Example:

```java
@GetMapping("/search")
public String searchUser(@RequestParam String name) {
    return "Searching for user: " + name;
}

```

‚úÖ Test in Browser/Postman:


```bash

GET http://localhost:8080/users/search?name=Amresh

```

üìå Output: "Searching for user: Amresh"

#### Returning Response with Status Codes (@ResponseStatus)

üîπ @ResponseStatus helps in customizing HTTP responses.


```java

@GetMapping("/{id}")
@ResponseStatus(HttpStatus.OK)  // Custom Status Code
public User getUser(@PathVariable int id) {
    return new User(id, "Amresh", "amresh@example.com");
}
```

‚úÖ Response Code: 200 OK

#### Exception Handling in REST APIs (@ControllerAdvice)

Spring provides @ControllerAdvice for global exception handling.

üîπ Handling Resource Not Found Exception

```java
@ResponseStatus(HttpStatus.NOT_FOUND)  // Return 404 Status
class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

```

üîπ Handle Exception Globally:

```java

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}

```

‚úÖ Now, if a user is not found, it will return 404 Not Found instead of a generic error.

‚úÖ Summary
- ‚úî Spring Boot makes it easy to create REST APIs using @RestController.
- ‚úî CRUD operations are implemented using @GetMapping, @PostMapping, @PutMapping, @DeleteMapping.
- ‚úî Path Variables (@PathVariable) and Query Parameters (@RequestParam) help in handling requests.
- ‚úî Exception Handling (@ControllerAdvice) improves API error responses.

